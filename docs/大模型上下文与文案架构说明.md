# 大模型上下文与文案架构说明

本文档描述当前游戏中「大模型上下文 / 记忆」与「文案内容」的架构设计，便于后续扩展或与后端/云函数对齐。

---

## 一、大模型上下文的架构（记忆与请求体）

### 1.1 设计思路

- **无状态请求**：每次玩家输入后，客户端构造**单次请求**发给裁决 API（或云函数），不维护服务端会话。
- **上下文 = 请求体**：大模型能看到的「记忆」完全由**当次请求的 payload** 提供，即「当前世界快照 + 最近几句对话 + 本条意图」。

### 1.2 请求体从哪里来：`buildAdjudicationPayload`

**位置**：`src/core/snapshot.ts` → `buildAdjudicationPayload(input)`。

**输入**：

- `saveData`：当前存档（可为 null，则用 config 默认状态）
- `playerIntent`：玩家本条输入（已 trim）
- `recentDialogue`：可选；若不传则用 `saveData.dialogueHistory.slice(-5)`

**输出**：`AdjudicationRequest`，即发给裁决 API 的 JSON 结构（见下）。

### 1.3 请求体结构（AdjudicationRequest）

| 字段 | 类型 | 含义 | 说明 |
|------|------|------|------|
| `player_state` | `PlayerState` | 玩家当前状态 | 来自 `saveData.player` 或 `DEFAULT_PLAYER_STATE`；含 attrs、legend、tags、reputation、resources、location、**ambition**（志向：unify/wealth，见服务端提示词说明） |
| `world_state` | `WorldState` | 世界当前状态 | 来自 `saveData.world` 或 `DEFAULT_WORLD_STATE`；含 era、flags、time、regionStatus、regions |
| `npc_state` | `NPCState[]` | NPC 列表 | 来自 `saveData.npcs` 或 `DEFAULT_NPC_STATE`；**会先经 contentRegistry 的 filterEntities("npc", ...) 做幻觉防御** |
| `event_context` | 可选 | 近期对话与叙事指令 | `recent_dialogue`：最近 5 条；>10 轮时含 `suggest_summary`、`summary_instruction`；**首轮**时含 `is_opening`、`opening_instruction`（根据志向生成首段内心独白）；每轮含 `narrative_instruction`（Level 3 长文案时增加括号内心戏） |
| `player_intent` | string | 玩家本条意图 | 原始输入文本 |
| `logical_results` | `LogicalResults` 可选 | 逻辑层既定事实 | 时间跳跃、属性增益、该时段世界大事；叙事必须基于此 |
| `logic_override` | `LogicOverride` 可选 | 强制失败约束 | 存在时 LLM 必须描写失败/撤退，见 `instruction` |
| `logic_db` | `LogicDbContext` | 三国结构化数据库 | 城池、武将（能力值、所在地、性格、话术风格、生卒年），供 LLM 参考以修正叙事幻觉 |

也就是说：

- **全量状态**：每轮都会发送**完整的** player / world / npc 状态，大模型不依赖「上一轮的回复」来记住数值。
- **对话记忆**：只传 **最近 5 条** 对话（`recent_dialogue`），没有更长历史或 token 级滑动窗口；更长历史只存在于本地存档中，用于展示与存档，不发给 API。

### 1.4 逻辑层（Pre-Adjudicator）与调用链

在 `buildAdjudicationPayload` 之后、调用 API 之前，会经过**逻辑预处理器** `applyHardConstraints(payload)`（`src/core/preAdjudicator.ts`）：

- **时间跳跃**：从 `player_intent` 解析「X 年」「修炼十年」等，推进 `world_state.time`，并从 `config/worldTimeline.ts` 取该区间内大事写入 `logical_results.world_changes`。属性不在此处按年定额增加，由裁决 API 根据叙事通过 effects 返回增减。
- **状态锁定**：若意图不可能（如武力不足却要击杀吕布），写入 `logic_override`，要求 LLM 必须描写失败。

请求体中的 `player_state`、`world_state` 在逻辑层处理后**已是更新后的值**；`logical_results` 供服务端注入 Prompt，强调「既定事实，叙事必须基于此」。服务端提示词说明见 `docs/逻辑层与叙事层_服务端提示词说明.md`。

**调用链（客户端）**：

1. 玩家点击发送 → `gameApp.submitInput()`
2. `buildAdjudicationRequest(intent)` → `buildAdjudicationPayload(...)`
3. **`applyHardConstraints(payload)`** → 得到带 `logical_results` / `logic_override` 且状态已更新的 payload
4. `callAdjudication(payload)` 发 POST 到裁决 API 或云函数
5. 服务端用 payload（含 `logical_results`）拼 prompt，调大模型，返回 `narrative` + `effects` + `state_changes`
6. 成功返回后，若有 `logical_results`，客户端将请求体中的 `player_state`、`world_state` 同步回存档并自动保存

### 1.5 客户端本地「记忆」与上限

- **对话历史**：`GameSaveData.dialogueHistory`（即 `runtime.dialogueHistory` 与存档中的一致）。
  - **存档内上限**：`saveManager` 的 `storageLimits.maxDialogueHistory = 100` 条；超出时从**头部**裁掉，只保留最近 100 条。
  - **发给 API 的**：始终只用 **slice(-5)**，即最近 5 条。
- **事件日志**：`GameSaveData.eventLog`，上限 `maxEventLog = 500`；当前**不**参与请求体，仅存档用，供将来扩展（如做摘要或筛选关键事件再塞进 event_context）。
- **世界快照摘要**：`stateMachine.ts` 中的 `buildWorldSnapshot()` 目前为占位（返回 "世界状态快照占位"），**未**接入请求体；若后续要在请求里加「世界摘要」字段，可在此扩展。

**小结**：  
大模型的「上下文/记忆」= **当次请求里的全量状态 + 最近 5 条对话 + 本条意图**。更长对话只存在客户端存档中，不做 token 级滑动窗口或服务端会话。

---

## 二、文案内容的架构（固定文案与 Prompt）

### 2.1 内容注册表：contentRegistry

**位置**：`src/core/contentRegistry.ts`。

- **Prompt 注册表**：`registerPrompt(key, value)` / `getPrompt(key)` / `listPrompts()`。  
  - 用于按 key 存一段字符串（如 system、safety、new_player）。  
  - **当前客户端在发起裁决请求时并未调用 `getPrompt()`**，即请求体里**不包含**这些文案。
- **实体注册表（幻觉防御）**：`registerEntity(type, id)` / `filterEntities(type, items)`。  
  - 在 `buildAdjudicationPayload` 里会对 `npc_state` 调用 `filterEntities("npc", npcState)`，只保留已注册的 NPC，避免把未定义 ID 传给大模型。

### 2.2 默认 Prompt 的注入：prompts.ts

**位置**：`src/agents/prompts.ts`。

- `PROMPT_KEYS`：`SYSTEM`、`SAFETY`、`NEW_PLAYER`（常量 key）。
- `bootstrapDefaultPrompts()`：向 contentRegistry **注册** 占位 System Prompt（"占位 System Prompt：请保持古风旁白，后续由内容团队提供正式文案。"）。  
- **谁用**：`bootstrapDefaultPrompts` 若在入口被调用，只是把文案**放进注册表**；**云函数/后端目前使用各自独立的 SYSTEM_PROMPT**，与 contentRegistry **未打通**（即服务端不会从客户端拉取 `getPrompt("system")`）。

### 2.3 文案的分布（客户端）

| 类型 | 位置 | 说明 |
|------|------|------|
| 开局旁白 | `config/index.ts` → `INITIAL_DIALOGUE` | 新档/首次进入时显示的引导；与存档里默认 `dialogueHistory` 一致 |
| 默认世界/NPC | `config/index.ts` → `DEFAULT_PLAYER_STATE` / `DEFAULT_WORLD_STATE` / `DEFAULT_NPC_STATE` | 数值与展示用 name、era 等 |
| System 等 Prompt | `agents/prompts.ts` → `bootstrapDefaultPrompts()` → contentRegistry | 当前仅客户端占位；实际大模型用的 System Prompt 在**服务端/云函数**配置 |
| 界面与系统话术 | `gameApp.ts`、`renderer.ts`、`contentGuard.ts`、`saveManager.ts` 等 | 按钮、提示、审核失败原因、存档名等，见《内容文案规范_供内容AI使用》 |

### 2.4 裁决 API 返回的「文案」

- **narrative**：大模型生成的叙事段落，客户端经 `sanitizeNarrative` 后追加到 `dialogueHistory` 并展示。
- **effects**：如 `strength+10`、`legend+5`，客户端解析后更新 `player` 属性，不直接作为文案展示。

**小结**：  
文案架构 = **客户端 contentRegistry + config + 各模块内嵌字符串**；大模型侧的 System Prompt 在服务端独立维护，与客户端注册表尚未打通。若需「一处改、两端一致」，需要服务端从同一数据源读（例如读取 contentRegistry 导出的配置或接口）或由部署流程同步文案。

---

## 三、结构示意（便于和另一个 AI 或后端对齐）

```
[ 玩家输入 ]
      ↓
  submitInput
      ↓
  buildAdjudicationRequest(intent)
      ↓
  buildAdjudicationPayload({
    saveData,           ← 当前存档（含 dialogueHistory）
    playerIntent,       ← 本条输入
    recentDialogue      ← saveData.dialogueHistory.slice(-5)
  })
      ↓
  AdjudicationRequest = {
    player_state,       ← 全量
    world_state,        ← 全量
    npc_state,          ← 全量，但经 filterEntities("npc", ...)
    event_context: { recent_dialogue: [ 最近 5 条 ] },  ← 仅 5 条
    player_intent
  }
      ↓
  callAdjudication(payload)  →  POST 到裁决 API / 云函数
      ↓
  服务端用 payload + 自己的 SYSTEM_PROMPT 调大模型
      ↓
  返回 narrative + effects + state_changes
      ↓
  客户端：appendDialogue(narrative)、更新 player/world、autoSave
         dialogueHistory 本地保留最多 100 条，但下次请求只发最近 5 条
```

- **文案**：System Prompt 在服务端；客户端负责开局旁白、界面、审核提示等，见《内容文案规范_供内容AI使用》。
- **记忆**：无服务端会话；每轮 = 全量状态 + 最近 5 条对话 + 本条意图。
