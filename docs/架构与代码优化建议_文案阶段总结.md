# 架构与代码优化建议（文案阶段总结）

从**资深架构师**视角，对当前项目做一轮框架与代码 check，在既有《架构与技术优化建议》基础上补充现状数据与可执行项。文案与玩法主流程已成型，本阶段重点：**可维护性、边界清晰、可测性与后续扩展成本**。

---

## 一、现状概览

### 1.1 体量与热点

| 文件/模块 | 行数（约） | 说明 |
|-----------|------------|------|
| `gameApp.ts` | ~1266 | 主控单文件，phase/触摸/提交/裁决/渲染/本地指令/存档全集中 |
| `renderer.ts` | ~1006 | 整屏绘制、对话区缓存、弹窗与游戏结束层 |
| `preAdjudicator.ts` | ~562 | 预裁决：时间、体力、生理失败、logic_override、event_context 补充 |
| `snapshot.ts` | ~237 | 构建 AdjudicationRequest，依赖 eventContextPipeline、sanguoDb、BondSystem |
| `eventContextPipeline.ts` | ~190 | 叙事约束与引导键值，供 snapshot 合并进 event_context |

- **gameApp** 内对 `runtime` 的直接读写约 **111 处**，单文件承担职责过多，修改与回归成本高。
- **dialogueHistory** 存在「双源」：`runtime.dialogueHistory` 与 `currentSaveData.dialogueHistory`，需通过 `syncDialogueToRuntime` / `addDialogueHistory` 手动同步，易漏一致性问题。

### 1.2 数据流（玩家输入 → 裁决 → 渲染）

```
submitInput
  → tryHandleLocalIntent（本地指令则 return）
  → ensurePlayerInputSafe
  → buildAdjudicationRequest（snapshot.buildAdjudicationPayload + 跳跃时 recentDialogue 压缩）
  → handlePlayerAction（上报 + actionProcessor → preAdjudicator.applyHardConstraints）
  → callAdjudication
  → handleAdjudicationResult（replaceModelSelfDisclosure → sanitizeNarrative → 写状态 → applyTypewriterCompletion → startTypewriter）
  → render（按 phase 分支：splash / privacy / creation / playing）
```

链路清晰，但**整条链路除 localIntents 外都挂在 gameApp 或从 gameApp 传参**，不利于「只测裁决流程」或「只测 UI 态」的隔离测试。

---

## 二、优化建议（按优先级）

### 2.1 【高】gameApp 瘦身与职责边界

**问题**：单文件 1266 行，集 phase、触摸、本地指令、提交、裁决结果、渲染编排、存档/重开/广告/反馈于一体，难以定位变更影响面。

**建议**：

1. **已拆出且可继续强化的模块**
   - **adjudicationFlow.ts**：已含 `buildAdjudicationRequest`、`handleAdjudicationResult`、`applyTypewriterCompletion`。建议将 **submitIntentForAdjudication** 的「组装 payload → 调 API → 调 handleAdjudicationResult」整段从 gameApp 迁入 adjudicationFlow，对外只暴露一个 `submitAndHandleAdjudication(intent, runtimeRef, ctx)`，ctx 提供 saveData、dialogueHistory 的读与 sync、render、startTypewriter 等回调。gameApp 仅负责「取 trimmed → 调 submitAndHandleAdjudication → 根据结果 render」。
   - **lifecycle.ts**：已抽象 loadLatestSave、manualSave、onAppHide，且接受 SaveManagerLike 与 RuntimeSaveRef。保持「只做编排、不碰 wx」即可。
   - **localIntents.ts**：已纯函数化。**tryHandleLocalIntent** 仍在 gameApp 内实现各分支（help/save/meta…）；可把「执行分支」抽成 `executeLocalIntent(type, context)`，context 含 appendDialogue、render、loadLatestSave 等注入，gameApp 只负责 `const type = getLocalIntentType(intent); if (type) return executeLocalIntent(type, context);`。

2. **收敛对 runtime 的写**
   - 引入单一更新入口，例如 `updateRuntime(gameApp, patch: Partial<GameRuntime>)`，在 patch 里做浅合并并可选 log；新逻辑优先走该入口，便于后续加「状态快照/时间旅行」或调试面板。

3. **phase 转移集中**
   - 将 `phase = "splash" | "privacy" | ...` 的赋值收口到少量函数，如 `transitionToPhase(phase)`，在函数内集中处理「进入该 phase 时的副作用」（如进入 playing 时 startSession、拉建议动作）。减少在 handleTouch、submitInput 等处散落的 `runtime.phase = "xxx"`。

---

### 2.2 【高】对话与存档单一数据源

**问题**：`runtime.dialogueHistory` 与 `currentSaveData.dialogueHistory` 双写/双读，需记得 syncDialogueToRuntime、addDialogueHistory 成对出现，易漏或顺序错。

**建议**：

1. **明确权威数据**
   - 约定：**权威数据**仅为 `currentSaveData`（含 `dialogueHistory`）。`runtime.dialogueHistory` 仅作为「当前帧展示用」的**只读派生**：`runtime.dialogueHistory = currentSaveData?.dialogueHistory ?? []`，在 loadLatestSave、addDialogueHistory 写 saveData 后统一调用一次 `syncDialogueToRuntime()` 刷新派生。
   - 或更彻底：`runtime` 不再持有一份 `dialogueHistory` 数组，改为 getter：`get dialogueHistory() { return this.currentSaveData?.dialogueHistory ?? []; }`，所有「追加对话」只写 saveData，避免两处独立 push。

2. **写入路径唯一**
   - 所有「追加一条对话」必须经 `saveManager.addDialogueHistory(saveData, content)`，再由调用方执行一次 `syncDialogueToRuntime()`。禁止在 gameApp 或 adjudicationFlow 里直接 `runtime.dialogueHistory.push(...)`（若仍保留 runtime.dialogueHistory 副本）。

---

### 2.3 【中】预裁决与 event_context 边界

**问题**：preAdjudicator 既算 logical_results（时间、体力、生理因子），又往 payload.event_context 里塞大量叙事指令；snapshot 已通过 eventContextPipeline 写 event_context，preAdjudicator 再合并一轮，职责有重叠，新人难以判断「某条指令该放在 snapshot 还是 preAdjudicator」。

**建议**：

1. **约定分工**
   - **snapshot + eventContextPipeline**：只负责「与当前 saveData / 意图 / 对话轮次 / 世界状态」相关的**静态或缓变**叙事约束（地点权威、去重、季节、愿望、关系规则、时间跳跃过场白等）。
   - **preAdjudicator**：只负责**本回合逻辑结果**（time_passed、stamina_cost、physiological_success_factor、logic_override、game_over_reason）以及「因本回合判定结果才需要的」少量 event_context 补充（如生理失败时的叙事指令）。避免在 preAdjudicator 内重复写入「通用」叙事指令（如 narrative_safety_instruction）。

2. **文档化**
   - 在 `docs/` 或 eventContextPipeline.ts 顶部用一段注释列出「event_context 键名 → 来源（snapshot / preAdjudicator）」表，便于后续加新键时选对位置。

---

### 2.4 【中】效果应用与 core 边界

**问题**：`applyPlayerStateChanges`、`applyNpcRelationEffects`、`applyTypewriterCompletion` 等在 adjudicationFlow 中调用，但具体解析（computePlayerStateDelta、applyHealthFromEffects 等）在 core/effectsApplier；adjudicationFlow 仍依赖 core 的多种 apply*，接口分散。

**建议**：

1. **统一入口（可选）**
   - 在 effectsApplier 暴露单一函数：`applyAdjudicationResult(saveData, response, requestPayload)`，内部依次执行 state_changes、result.effects、time_lapse_side_effects、world 更新、active_goals，并返回「是否有 game over」等摘要。adjudicationFlow 只调该函数 + autoSave + syncFromSave + setSuggestedActions，减少对多种 apply* 的逐个调用。

2. **保持 core 纯逻辑**
   - 所有「根据 effects 字符串更新 state」的逻辑保留在 core，不依赖 wx、不依赖 runtime；便于单测与复用。

---

### 2.5 【中】错误处理与重试一致性

**问题**：裁决失败、审核失败、网络超时、replaceModelSelfDisclosure 等分散在 adjudicationFlow、gameApp、contentGuard；重试逻辑（如「审核不通过是否重试一次」）未统一策略。

**建议**：

1. **裁决调用处**
   - 在 `submitIntentForAdjudication` 或 adjudicationFlow 内统一 catch：网络错误 → 提示「裁决请求失败」并可选重试 1 次；HTTP 4xx/5xx → 提示并记录 feedbackLogger；narrative 含 [ERROR] 或模型自我披露已替换 → 仅记录或上报，不重复弹窗。避免同一类错误在多处用不同文案或不同是否重试。

2. **审核失败**
   - sanitizeNarrative 不通过时，当前已 recordSanitizeFailure 并展示替代文案；若产品希望「审核不通过时自动重试一次请求」，可在 handleAdjudicationResult 内检测 result.reason 为审核类时，自动再调一次 callAdjudication（同一 payload），仅重试 1 次并限制频率，避免死循环。

---

### 2.6 【中】类型与契约

**现状**：AdjudicationRequest / AdjudicationResponse、LogicalResults、LogicOverride 等在 `services/network/adjudication.ts` 定义，core（snapshot、preAdjudicator）与 app 均依赖该类型；云函数为 JS，无类型共享。

**建议**：

1. **契约文档**
   - 在 `docs/` 下维护 `adjudication-api.md`（或从 TS 类型生成 JSON Schema），列出 Request/Response 的字段与含义、event_context 常用键、logical_results 各字段含义。便于云函数与多端对齐、Mock 与自动化测试。

2. **存档版本**
   - 继续在 saveManager.load 中按 meta.version 做迁移；任何对 GameSaveData 的增删字段都配套一次 migrate 并 bump SAVE_VERSION，避免旧档损坏或缺字段导致运行时异常。

---

### 2.7 【中】构建与体积

**现状**：esbuild 单次打出 game、main、config、save 四个 bundle；未在脚本内输出各文件 size，首包 1MB 限制需人工关注。

**建议**：

1. **构建后输出体积**
   - 在 buildOnce 的 copyArtifacts 之后，读取 tempDir 下各 .min.js 的 size，打印到控制台（如 `main.min.js: 856 KB`），并在文档中注明「首包预算」与「超 1MB 时考虑分包或按需加载 data/sanguoDb」。

2. **配置与数据分离**
   - 保持 config 为运行时常量（API、超时、安全宪法等）；大型静态表（NPC、时间线、地区）留在 data/。若未来多剧本，可将 data 拆为「基础 + 剧本 A/B」便于按需加载或分包。

---

### 2.8 【低】Prompt 与云函数双端

**现状**：云函数内 SYSTEM_PROMPT 为硬编码字符串；安全宪法、叙事安全、越狱应对、时间跳跃等通过 event_context 由客户端注入，双端已对齐。

**建议**：

- 若希望「宪法 / 系统级说明」也由服务端统一维护，可考虑云函数从环境变量或共享配置读取一段「系统前缀」再拼到 SYSTEM_PROMPT 前；当前通过 event_context 注入已可接受，优先级低。

---

### 2.9 【低】渲染与性能

**现状**：按 phase 分支渲染；对话区有离屏缓存与 invalidateDialogueCache；打字机与滚动时通过 needsHighFrequencyRender 提帧率。

**建议**：

- 若后续增加 phase 或大块 UI，可将「phase → render 函数」表驱动，减少 if/else。对话区仅在超长对话或低端机掉帧时再考虑脏区或局部重绘；当前体量可观察为主。

---

### 2.10 【低】内容与文案索引

**现状**：文案与提示分布在 config、splash、characterCreation、actionSuggestions、agents/prompts、云函数内。

**建议**：

- 在 `docs/` 维护一份「内容与文案所在文件」索引（如：开局引导 → splash.ts；安全/越狱 → config；行动建议 → actionSuggestions + 云函数 suggested_actions），方便策划/内容定点修改。若未来多语言，可先将用户可见串收口到 key 查表再接 i18n。

---

## 三、优先级汇总

| 优先级 | 方向 | 建议项 | 预期收益 |
|--------|------|--------|----------|
| 高 | 结构 | gameApp 瘦身：提交与裁决整段迁入 adjudicationFlow，本地指令执行迁入 executeLocalIntent | 降低单文件复杂度，便于单测与协作 |
| 高 | 状态 | dialogueHistory 单一数据源：权威仅在 saveData，runtime 只读派生或 getter | 消除双写与一致性问题 |
| 中 | 边界 | 明确 event_context 来源（snapshot vs preAdjudicator），并文档化 | 新人可快速判断新键放哪 |
| 中 | core | effects 应用可收口为 applyAdjudicationResult 单入口（可选） | 接口更清晰，adjudicationFlow 更薄 |
| 中 | 错误 | 裁决/审核错误与重试策略统一在一处 | 体验一致、避免重复弹窗 |
| 中 | 契约 | 裁决 API 文档或 JSON Schema + 存档版本与迁移规范 | 云函数与多端对齐、Mock 与回归 |
| 中 | 构建 | 构建后打印各 bundle 体积 + 首包预算说明 | 控制包体、提前发现膨胀 |
| 低 | Prompt | 云函数 SYSTEM_PROMPT 与宪法同源（可选） | 配置统一，非必须 |
| 低 | 渲染 | phase → render 表驱动 + 脏区（按需） | 扩展 phase/UI 时更清晰 |
| 低 | 内容 | 内容文件索引 + 多语言 key 预留 | 运营与 i18n 友好 |

---

## 四、建议落地顺序

1. **第一阶段（1～2 个迭代）**  
   - 明确并落实 **dialogueHistory 单一数据源**（含 getter 或只读派生 + 写入路径唯一）。  
   - 将 **submitIntentForAdjudication 整段**迁入 adjudicationFlow，gameApp 只调 `submitAndHandleAdjudication(...)` 并 render。

2. **第二阶段**  
   - **executeLocalIntent** 抽出，gameApp 只做 getLocalIntentType + executeLocalIntent。  
   - **event_context 键来源** 文档化；preAdjudicator 只写「本回合逻辑相关」的 event_context。

3. **第三阶段**  
   - 裁决/审核 **错误与重试** 统一；构建 **体积输出** 与 **adjudication-api.md**；按需做 **applyAdjudicationResult** 收口与 **phase 表驱动**。

整体不改变现有功能与产品行为，只提升可维护性、可测试性与后续扩展时的改造成本。若你希望先落某一项（例如只做 dialogueHistory 单一数据源），可以指定模块，我可以按该模块给出更具体的改动步骤与示例补丁。
