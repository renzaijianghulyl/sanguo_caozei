# 四项重构方案评估

基于当前代码结构（renderer 虚拟化、state 中 Bond/NPCState、snapshot 构建请求、scroll 直接赋值）的可行性与建议。

---

## 1. ChatRenderer + 离屏缓冲（历史对话离屏、主屏只 drawImage）

### 方案要点
- 抽成 `ChatRenderer` 类，历史对话绘制到离屏 Canvas，主屏只根据 `scrollY` 做 `drawImage` 拷贝，不再在每帧 `draw()` 里对气泡直接 `fillText`。
- 目标：解决文字重叠、减少卡顿。

### 评估

| 维度 | 结论 |
|------|------|
| **文字重叠** | 当前重叠来自**逻辑**（叙事在打字机完成前写入对话），已在流程上修复。离屏 + drawImage 不解决「写错时机」类问题，对重叠帮助有限。 |
| **卡顿** | 已有虚拟化：只对可见区间气泡做 `fillText`，未画整表。离屏后若「仅滚动时只 blit」则能减少滚动时的 measureText/wrapText/fillText，对**纯滚动**有收益。 |
| **实现成本** | 高。需：离屏 Canvas 尺寸 = 内容总高 × 宽；每次 `dialogueHistory` 或 `typingState` 变化都要重绘离屏（至少增量或整块）；打字机每字都可能改「当前条」，离屏要频繁更新或与主屏分层。 |
| **风险** | 小游戏对 Canvas 尺寸/数量有限制；总高很大时离屏会很高，内存与首绘成本高；若离屏与主屏不同 DPR 还需处理缩放。 |

### 建议
- **不推荐**「整段历史一张离屏」：成本高、失效频（新消息/打字机），收益主要在纯滚动。
- **可做折中**：  
  - **分层**：底层「稳定历史」用离屏（仅当 `dialogueHistory` 不变时更新），顶层仍用现有虚拟化只画「当前打字气泡 + 底部提示」。滚动时主屏只 drawImage(离屏, sx, sy, w, h) + 顶层。  
  - 或**分块离屏**：按 2～3 屏高切条，只缓存当前滚动附近的条，减少单张离屏尺寸。  
- 若仍卡顿，优先做**换行结果缓存**和**打字机节流**（见《对话界面优化方案》），再考虑离屏。

---

## 2. BondSystem：关系逻辑解耦、亲密度衰减

### 方案要点
- 从 `NPCState` 中解耦关系逻辑，新建 `BondSystem` 类。
- 职责：基于 `NPCRecord` 的初始关系导入；基于 `WorldState.time` 的亲密度随时间衰减。

### 评估

| 维度 | 结论 |
|------|------|
| **与现状** | `NPCState` 已有 `player_favor`、`player_relation`、`relations`、可选 `bond`（Bond：affinity, milestones, last_seen_world_time）。`npcRecordToState` 只设基础字段，未设 `bond`；`effectsApplier` 只做 effect 解析与写回，无时间衰减。 |
| **解耦** | 把「从 NPCRecord 生成/更新 NPC 状态」和「按时间衰减」放进 BondSystem，存档仍用现有 `saveData.npcs` 结构，BondSystem 只负责计算与建议更新，**可行且清晰**。 |
| **初始导入** | 当前 `getDefaultNPCState` / `npcRecordToState` 可迁到 BondSystem，或由 BondSystem 封装调用，并统一在这里设置 `bond`（如 last_seen = 当前 world.time）。 |
| **衰减** | 需定公式：如每 N 月未见面 affinity/favor 减 X，或按「距 last_seen 月数」分段衰减。在**读档或构建裁决快照前**调用 BondSystem.applyDecay(saveData) 或 BondSystem.getDecayedNpcs(npcs, worldTime)，再写回或仅用于本次请求。 |

### 建议
- **推荐实现**。  
- 接口建议：  
  - `BondSystem.importFromRecords(records: NPCRecord[], worldTime: WorldTime): NPCState[]`（或合并进现有 save 的 npcs）。  
  - `BondSystem.applyDecay(saveData: GameSaveData): void` 或 `getDecayedNpcs(npcs, worldTime): NPCState[]`，在 snapshot 构建前或 load 后调用。  
- 与现有 `player_favor` 二选一或统一：要么以 `bond.affinity` 为唯一来源、`player_favor` 为展示用派生；要么保留 `player_favor` 并在其上做衰减，Bond 只做「上次见面时间」等扩展。建议先统一成一种数值来源，避免两套并行。

---

## 3. 叙事注入：大时间跨度 + BondSystem + 人情冷暖 → Prompt 关键词

### 方案要点
- 修改「NarrativeGenerator」：当时间跨度较大时，先通过 BondSystem 检索关联 NPC 的变迁，将「人情冷暖」转为 Prompt 关键词，强制 LLM 做小说化分段描述。

### 评估

| 维度 | 结论 |
|------|------|
| **现状** | 没有单独的 NarrativeGenerator 类。叙事由：`snapshot.buildAdjudicationPayload` 提供 `event_context`（含 relationship_rules、narrative_instruction 等）；云函数/LLM 根据 payload 生成叙事。时间跨度在 preAdjudicator 里算（time_passed_months 等）。 |
| **落点** | 「大时间跨度」可在 `buildAdjudicationPayload` 或请求前逻辑里判断（如 `time_passed_months >= 12`）；在此处调 BondSystem 取「与玩家有关 NPC 的变迁摘要」，写入 `event_context`，供服务端拼进 Prompt。 |
| **BondSystem 扩展** | 需提供如 `BondSystem.getSummaryForNarrative(npcs, worldTime, timePassedMonths): { keywords: string[], npcChanges: string[] }`，内部用 last_seen、death、衰减结果等生成「谁疏远、谁离世、谁仍在」等短句或关键词。 |
| **Prompt** | 在 `event_context` 中增加字段，如 `bond_narrative_hints: string[]`，并在云函数/系统提示中约定：当存在该字段时，必须将这些关键词融入叙事，并以分段/小说化方式呈现。 |

### 建议
- **推荐实现**，且依赖 BondSystem（方案 2）先有「衰减 + 上次见面」等数据。  
- 实现顺序：BondSystem 落地 → 在 snapshot（或调用 snapshot 的流程）里根据 `time_passed_months` 调用 BondSystem.getSummaryForNarrative，写入 event_context → 云函数侧增加对 bond_narrative_hints 的说明与示例。  
- 无需新增「NarrativeGenerator」类，在现有 snapshot + event_context 上扩展即可。

---

## 4. 平滑 Tween 滚动（新文字打出时自动平滑上推）

### 方案要点
- 新文字打出时，不瞬间把视图切到底，而是用 Tween 动画平滑上推。

### 评估

| 维度 | 结论 |
|------|------|
| **现状** | `dialogueScrollOffset` 直接赋值（如新消息时设为 maxScroll，或触摸拖拽）。无插值。 |
| **实现** | 在 gameApp 中增加「目标 scroll」与「当前 scroll」；每帧 `current += (target - current) * 0.2` 或 150ms ease-out；当接近 target 时置为 target 并停止。需在 tween 期间保持渲染（如 `needsHighFrequencyRender` 在 scrollTweenActive 时为 true）。 |
| **触发** | 在「新消息导致需要滚到底」的逻辑处（例如打字机 onComplete 或首帧对话区对齐）不直接 `setDialogueScrollOffset(maxScroll)`，改为 `setDialogueScrollOffsetAnimated(maxScroll)`。 |
| **与触摸** | 用户拖拽时可直接设 target = 当前拖拽结果，或取消 tween 以手指为准。 |

### 建议
- **推荐实现**，改动集中、收益明显。  
- 实现要点：  
  - 暴露 `setDialogueScrollOffsetAnimated(target: number)`，内部设 `targetScrollOffset = target`，每帧在 gameLoop 里做一次插值并 `setDialogueScrollOffset(current)`。  
  - 若 `Math.abs(current - target) < 1` 则设 `current = target` 并清除 tween 状态。  
  - 触摸开始时可将 `targetScrollOffset` 设为当前 offset，避免与手指冲突。

---

## 总体建议与实施顺序

| 顺序 | 方案 | 建议 | 理由 |
|------|------|------|------|
| 1 | Tween 滚动 | ✅ 先做 | 独立、小改、体验提升直接 |
| 2 | BondSystem | ✅ 做 | 关系与衰减逻辑清晰，为方案 3 打基础 |
| 3 | 叙事注入（Bond 关键词） | ✅ 做 | 依赖 BondSystem，在 snapshot/event_context 扩展即可 |
| 4 | ChatRenderer + 离屏 | ⚠️ 折中或延后 | 成本高，收益主要在纯滚动；优先换行缓存与节流，再考虑分层/分块离屏 |

如需，我可以按上述顺序从「Tween 滚动」或「BondSystem」开始写具体接口与调用点（含需要改动的文件列表）。
