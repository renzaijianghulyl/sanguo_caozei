# 三国文字冒险 · 产品与技术框架（重构指南）

本文档作为整体重构的蓝图，兼顾产品定位与技术架构，供迭代开发与代码整理参考。

---

## 一、产品框架

### 1.1 产品定位

**三国文字冒险** 是一款基于微信小游戏的 LLM 驱动文字冒险游戏：

- **核心玩法**：玩家以文字输入意图，由 LLM 裁决并推进剧情；数值（武力、智力、传奇度等）影响剧情走向与 NPC 态度。
- **目标用户**：轻度玩家、三国题材爱好者，追求碎片化体验。
- **变现模式**：激励视频广告（可选内购预留）。
- **合规要求**：所有输入输出经 `wx.msgSecCheck` + 本地敏感词过滤。

### 1.2 核心功能清单

| 模块 | 功能 | 优先级 |
|------|------|--------|
| **剧情推进** | 玩家输入意图 → LLM 裁决 →  narrative + 状态变更 | P0 |
| **数值系统** | 武力/智力/魅力/运气/传奇度/气势，影响剧情与判定 | P0 |
| **存档系统** | 手动存档、自动存档、读档、多槽位 | P0 |
| **基础指令** | 存档、读档、帮助、你是谁、广告（本地拦截，不调 LLM） | P0 |
| **内容安全** | 本地敏感词 + `wx.msgSecCheck`，输入与叙事双轨校验 | P0 |
| **激励广告** | 剧情节点/体力耗尽触发，可优雅降级 | P1 |
| **运营位** | 公告/福利占位，支持远程配置 | P2 |

### 1.3 用户主流程

```
启动 → 加载/新档 → 显示开局旁白 → 输入意图
  → [本地指令?] 是 → 直接处理（存档/读档等）
  → 否 → 安全审核 → 调用裁决 API → 解析 narrative + state_changes
  → 更新对话、属性、世界状态 → 自动存档 → 继续输入
```

---

## 二、技术框架

### 2.1 分层架构

```
┌─────────────────────────────────────────────────────────────┐
│  Entry (game.ts)                                             │
│  wx.onShow → bootstrap → initGame → gameLoop                 │
├─────────────────────────────────────────────────────────────┤
│  App 层 (app.ts)                                             │
│  生命周期、触摸分发、输入提交、渲染触发、本地指令路由          │
├──────────────┬──────────────┬──────────────┬────────────────┤
│  Services    │  Core        │  UI          │  Utils         │
│  - 存档      │  - 状态模型  │  - 布局      │  - wx 封装     │
│  - 网络      │  - 实体校验  │  - 渲染      │  - 对话缓冲    │
│  - 安全      │  - 快照构建  │  - 输入状态  │  - 请求封装    │
│  - 广告      │  - Prompt 注册│              │                │
├──────────────┴──────────────┴──────────────┴────────────────┤
│  Config (index.ts)                                           │
│  默认状态、API 地址、重试策略                                 │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 目标目录结构

```
src/
├── entry/
│   └── game.ts              # 微信入口，仅负责 wx 生命周期与 bootstrap
├── app/
│   └── gameApp.ts           # 应用级逻辑：初始化、循环、触摸、输入路由
├── core/
│   ├── state.ts             # 类型与默认状态（纯数据）
│   ├── snapshot.ts          # 世界快照构建（供 LLM 请求）
│   └── contentRegistry.ts   # Prompt / 实体注册表
├── services/
│   ├── storage/
│   │   └── saveManager.ts   # 存档读写、裁剪、元信息
│   ├── network/
│   │   └── adjudication.ts  # 裁决 API 封装（含重试、超时）
│   ├── security/
│   │   └── contentGuard.ts  # 本地敏感词 + msgSecCheck
│   └── ads/
│       └── rewardedAd.ts    # 激励视频
├── ui/
│   ├── layout.ts            # 布局计算（无副作用）
│   ├── renderer.ts          # Canvas 绘制
│   └── input.ts             # 输入状态管理
├── utils/
│   ├── wxHelpers.ts         # wx API 封装（Canvas、触摸、键盘、request）
│   └── dialogueBuffer.ts    # 对话缓冲工具
├── config/
│   └── index.ts             # 配置常量
├── agents/
│   └── prompts.ts           # Prompt 注册（业务无感）
└── types/
    └── global.d.ts
```

### 2.3 模块职责边界

| 模块 | 职责 | 不负责 |
|------|------|--------|
| **entry** | 监听 wx 生命周期，调用 app 启动 | 业务逻辑、UI、存储 |
| **app** | 初始化、主循环、触摸路由、输入提交、本地指令 | 具体绘制、网络实现、安全实现 |
| **core** | 状态类型、快照构建、实体/ Prompt 注册 | 持久化、网络、UI |
| **services** | 存档、网络、安全、广告 | 触摸坐标、布局、渲染 |
| **ui** | 布局、绘制、输入状态 | 业务规则、API 调用 |
| **utils** | wx 封装、通用工具 | 业务规则 |

### 2.4 数据流原则

- **单向**：Entry → App → Services / Core；UI 仅根据 App 提供的状态渲染，不反向调用业务。
- **纯函数优先**：布局、快照、对话裁剪等尽量无副作用，便于测试。
- **副作用集中**：存档、网络、广告、安全审核统一在 Services 层，App 通过接口调用。

---

## 三、重构原则

### 3.1 与现有代码的差异

| 当前问题 | 目标 |
|----------|------|
| app.ts 体量过大，职责混杂 | 拆出 gameApp、保持 app 薄 |
| 触摸、布局、渲染、业务耦合 | 分层清晰，接口明确 |
| 状态散落（runtime 大对象） | 收敛到 core/state，按模块划分 |
| 实体校验、快照逻辑未落地 | 在 core 中实现 snapshot、contentRegistry 实际使用 |
| 配置、默认状态与逻辑混在一起 | config 仅数据，逻辑引用 |

### 3.2 代码规范

1. **TypeScript 严格模式**，避免 `any`，必要时用 `unknown` 再收窄。
2. **Prompt 与文案** 统一在 `agents/prompts.ts` 或配置，业务代码不写死长字符串。
3. **错误处理**：网络、存储、安全等关键路径必须有 try/catch 与降级。
4. **禁止**：`eval`、`new Function`、`window`/`document`/`localStorage`（仅用 wx 能力）。

### 3.3 测试策略

- **SaveManager**：已有单测，保持并扩充（裁剪、版本兼容）。
- **快照构建**：新增 `snapshot.test.ts`。
- **本地指令**：新增 `gameApp.test.ts` 对指令路由做单测。
- **集成**：关键流程可加轻量 E2E（若后续支持）。

---

## 四、重构路线图（建议顺序）

| 阶段 | 内容 | 风险 |
|------|------|------|
| **1. 抽离与整理** | 新建 `app/gameApp.ts`，从 `app.ts` 迁出核心逻辑；保留 `app.ts` 为薄壳，调用 gameApp | 低 |
| **2. 服务层规范化** | 明确 saveManager、adjudication、contentGuard、rewardedAd 的接口；移除跨层依赖 | 低 |
| **3. 快照与实体** | 实现 `core/snapshot.ts`，接入 contentRegistry；裁决请求统一用快照 | 中 |
| **4. UI 解耦** | layout、renderer 只依赖传入状态，不直接读 runtime；明确 App → UI 的 props 类型 | 低 |
| **5. 入口瘦身** | `game.ts` 只做生命周期与 bootstrap，删除冗余导出 | 低 |
| **6. 测试补全** | 为核心模块补单测，修复/更新 build 与 CI | 低 |

---

## 五、对外接口约定（与后端/内容侧）

### 5.1 裁决 API

- **请求**：`POST`，JSON，含 `player_state`、`world_state`、`npc_state`、`player_intent`、可选 `event_context`。
- **响应**：`{ result: { narrative, effects? }, state_changes?: { player?, world? } }`。
- **客户端**：解析 `narrative` 展示，按 `state_changes` 与 `effects` 更新属性与世界状态。

### 5.2 内容协作

- 文案、Prompt 按 `docs/内容文案规范_供内容AI使用.md` 交付。
- 工程侧通过 contentRegistry、config 接入，不修改字段名与类型。

---

## 六、附录：与 .cursorrules 的对应关系

本框架与 `.cursorrules` 保持一致，并在以下方面细化：

- **目录结构**：采用上述目标结构，替代当前较扁平的 src 组织。
- **模块职责**：明确 app / core / services / ui / utils 边界。
- **数据流**：强调单向、纯函数、副作用集中。
- **重构顺序**：提供可执行的阶段划分，便于逐步落地。
