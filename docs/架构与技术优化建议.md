# 游戏架构与技术优化建议

从**游戏架构师 / 技术负责人**视角，对当前项目在结构、状态、可维护性与扩展性上的优化建议。与《完整性与稳定性优化建议》互补：彼处偏「稳」，此处偏「形」。

---

## 一、gameApp 瘦身与职责拆分

### 现状

- `src/app/gameApp.ts` 体量较大（约 1100+ 行），集中了：
  - 生命周期（init、loop、onHide）
  - 阶段与路由（splash / characterCreation / playing）
  - 输入与本地指令（tryHandleLocalIntent、submitInput、重试）
  - 裁决流程（buildAdjudicationRequest、handleAdjudicationResult、applyTypewriterCompletion、effects 解析）
  - 渲染编排（render、buildRenderState）
  - 触摸与键盘、存档同步、建议动作更新等
- 全局可变对象 `runtime` 被大量直接读写，`saveManager`、`typewriter` 等以单例形式直接依赖。

### 建议

1. **按职责拆文件（优先）**
   - **adjudicationFlow.ts**：`buildAdjudicationRequest`、`submitIntentForAdjudication`、`handleAdjudicationResult`、`applyTypewriterCompletion`、`applyPlayerStateChanges`、`applyNpcRelationEffects`。入参显式传 `runtime.currentSaveData` / `dialogueHistory` 或通过窄接口读写，避免在 gameApp 里堆逻辑。
   - **localIntents.ts**：`getLocalIntentType`、`getLastPlayerIntent`、`tryHandleLocalIntent` 及所有「帮助/存档/读档/重试」等分支。可接收 `runtime` 或「getState / dispatch」式接口，便于单测时 mock。
   - **lifecycle.ts**：`initGame`、`gameLoop`、`onAppHide`、`restartGame`、`loadLatestSave`、`manualSave`。只做「何时初始化 / 何时存读档 / 何时切 phase」，具体读写仍可委托给现有模块。
   - **gameApp.ts** 保留：`runtime` 定义、`render()` 编排、`handleTouch` 分发、对外 export（`submitInput`、`initGame` 等），以及各子模块的**组合**（调用 adjudicationFlow / localIntents / lifecycle），而不是实现细节。

2. **收敛对 runtime 的写**
   - 尽量通过「少量更新函数」改 runtime（例如 `updateRuntime(patch: Partial<GameRuntime>)`），便于以后加日志、快照或时间旅行调试；不必一步到位，可在新逻辑里先试一点。

---

## 二、状态与数据流

### 现状

- 单一可变 `runtime`，多处直接 `runtime.xxx = ...`。
- `dialogueHistory` 与 `currentSaveData.dialogueHistory` 需手动同步（如 `addDialogueHistory` 后要记得两边一致）；`playerAttributes` 由 `currentSaveData.player` 推导，在 `updateGameDataFromSave` 里同步到 runtime。

### 建议

1. **单一数据源**
   - 明确「权威数据」在 `currentSaveData`（及其中 `player` / `world` / `npcs` / `dialogueHistory`）。`runtime.dialogueHistory` 视为「当前会话的展示用副本」，仅在「加载存档 / 追加新对话 / 重开」时从 saveData 同步过来，避免两处独立 push。
   - 或：`runtime.dialogueHistory` 仅作 `currentSaveData.dialogueHistory` 的引用（若类型允许），写只写 saveData，读从 saveData 读，减少不一致窗口。

2. **效果应用可抽到 core**
   - `applyPlayerStateChanges`、`applyNpcRelationEffects` 本质是「根据 effects 字符串列表更新 PlayerState/NPCState」。可迁到 `core/` 或 `services/` 下纯函数：`applyEffects(saveData, effects) => newSaveData`（或就地 mutate 但接口返回 void），由 gameApp/adjudicationFlow 调用，便于单测与复用。

3. **phase 显式化（可选）**
   - 当前 `phase` 为字符串字面量，转移分散在多处。若后续加「设置页」「多存档选择」等，可考虑在 `core/stateMachine.ts` 或单独 `gamePhase.ts` 中定义：`Phase` 枚举、允许的 `PhaseTransition`、以及「进入某 phase 时执行的副作用」（如进入 playing 时拉一次建议动作）。gameApp 只负责「发事件」或「调 transition(to)」，不散落 if (phase===...) 分支。

---

## 三、依赖与可测试性

### 现状

- `saveManager`、`wx`、`typewriter` 在模块顶层或函数内直接使用，单测需改全局或 mock 模块。
- 部分逻辑已抽成纯函数（如 `getLocalIntentType`、`buildAdjudicationPayload`），单测友好；但「提交输入 → 裁决 → 写回状态」整条链路仍依赖真实或 mock 的 saveManager / 网络。

### 建议

1. **接口抽象（按需、渐进）**
   - **存储**：定义 `IStorage` / `ISaveManager`（load、save、addDialogueHistory 等），`SaveManager` 实现该接口；gameApp 或 lifecycle 通过参数或简单 DI 容器注入。测试时注入 `MockSaveManager`。
   - **裁决**：`callAdjudication` 已可 mock；若希望单测「整条提交流程」而不发真实请求，可将 `callAdjudication` 作为可注入依赖（默认实现为当前函数）。
   - **平台**：`wx` 已集中在 `wxHelpers`，测试环境可在此处做 `hasWx() ? wx : mockWx`，避免业务代码散落 `typeof wx !== "undefined"`。

2. **保持「纯逻辑」在 core/utils**
   - 凡不依赖 wx、不依赖 runtime 的「算结果」逻辑（解析 intent、算时间推进、校验关系与年龄），继续放在 `core/`、`utils/`，便于单测和复用。

---

## 四、渲染与性能

### 现状

- 每帧或事件后调用单一 `render()`，全量重绘；对话区有 `invalidateDialogueCache` 与缓存 canvas，打字机/滚动时通过 `needsHighFrequencyRender` 提高帧率。

### 建议

1. **按 phase 分支渲染（已有雏形）**
   - 继续保持「splash / characterCreation / playing」分支，避免在 playing 时仍算 creation 布局。若再增加 phase，可把「当前 phase 的 renderXxx」收口到一张表（phase -> render 函数），减少 if/else。

2. **对话区脏区（可选、后期）**
   - 若超长对话或复杂 UI 导致掉帧，可考虑：对话列表仅在有新增行或 scroll 时重算/重绘对话区 canvas，其余区域复用上一帧；或对「非对话区」做简单脏标记。当前体量可先观察，不必提前做。

3. **离屏与缓存**
   - 对话列表已用离屏 canvas 与 cacheKey，逻辑清晰；新增大块 UI 时继续沿用「先画到离屏，再 drawImage 到主画布」可避免重复排版计算。

---

## 五、构建与分包

### 现状

- 单次 build 产出 4 个 bundle（game、main、config、save），主逻辑与配置、存档分拆；小游戏主包限制 2MB（首包建议 1MB 内）。

### 建议

1. **监控体积**
   - 构建后记录各 entry 的 size（如脚本里已有 log），若 main.min.js 接近或超过 1MB，考虑：
     - 将 `data/sanguoDb`（npcs、timeline、regions）打成独立分包或按需加载；
     - 或把部分「非首屏必需」的模块动态 import（小游戏若支持）。
   - 文档中注明「首包预算」与「超出时可选策略」，便于后续接手的人做决策。

2. **配置与内容分离**
   - 运行时常量（API 地址、超时、开关）保留在 `config`；大型静态表（时间线、NPC 表）保留在 `data/`。若未来有「多剧本 / 多时期」，可把 `data/` 再拆为「基础 + 剧本 A/B」等，便于按需加载或分包。

---

## 六、类型与契约

### 现状

- `AdjudicationRequest` / `AdjudicationResponse`、`GameSaveData`、`PlayerState` 等已在 TypeScript 中定义清晰；云函数与客户端通过 JSON 通信。

### 建议

1. **API 契约文档或 JSON Schema**
   - 将 `AdjudicationRequest`、`AdjudicationResponse`（含 `result.suggested_actions` 等）导出为一份「裁决 API 契约」文档或 JSON Schema，便于：
     - 云函数/后端与多端对齐；
     - 后续做 Mock 或自动化测试。
   - 可在 `docs/` 下维护 `adjudication-api.md`，或从类型生成 schema（若引入工具链）。

2. **存档版本与迁移**
   - 已有 `SAVE_VERSION` 与部分迁移逻辑；后续若改 `GameSaveData` 结构，继续在 `load` 中按 `meta.version` 做迁移并更新版本号，避免旧档损坏或字段缺失导致运行时错误。

---

## 七、内容与配置集中

### 现状

- 文案与提示分布在 `config/index.ts`、`ui/splash.ts`、`ui/characterCreation.ts`、`data/actionSuggestions.ts` 等；规则类（如 NARRATIVE_SAFETY_INSTRUCTION）在 config。

### 建议

1. **内容入口索引（可选）**
   - 在 `docs/` 或代码注释中列出一份「内容与文案所在文件」索引（如：开局提示 → splash.ts；安全叙事 → config；行动建议 → actionSuggestions + 云函数返回），方便策划/内容同学定点修改，而不必搜全库。

2. **多语言预留（若未来需要）**
   - 若考虑 i18n，可先把「用户可见字符串」集中到若干 key（如 `content.splash.guide`），实现先走单语言查表；后续再接入多语言方案，避免届时大范围替换。

---

## 八、小结与优先级

| 方向           | 建议项                         | 优先级 | 说明                           |
|----------------|--------------------------------|--------|--------------------------------|
| 结构           | gameApp 按职责拆成多文件       | 高     | 利于维护与多人协作             |
| 状态           | 明确 dialogueHistory 单一来源  | 中     | 减少双写与一致性问题           |
| 效果应用       | effects 解析迁到 core 纯函数   | 中     | 易测、可复用                   |
| 依赖           | 存储/裁决接口抽象与注入        | 中     | 提升单测与换端能力             |
| phase          | 状态机或 phase 转移表           | 低     | 扩展新阶段时更清晰             |
| 渲染           | 按 phase 表驱动 + 脏区（可选）  | 低     | 性能与扩展新 UI 时考虑         |
| 构建           | 监控体积 + 分包/按需策略       | 中     | 首包超 1MB 时必做              |
| 契约           | 裁决 API 文档/JSON Schema       | 低     | 利于前后端与 Mock              |
| 内容           | 内容文件索引 / 多语言预留      | 低     | 按运营需求再做                 |

优先做 **gameApp 职责拆分** 与 **dialogueHistory / 存档单一数据源**，再视需求做 **effects 纯函数化** 与 **存储/裁决接口抽象**，其余可按迭代节奏逐步落地。若你希望先动某一块（例如只拆 adjudication 流程），可以指定模块，我按该模块给出更具体的拆分方案与接口设计。
